{% load static %}
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Pixel RPG — Adventure</title>
<style>
  body{background:#0b1020;color:#fff;font-family:Meiryo, sans-serif;text-align:center}
  #ui{margin:8px auto; width:740px; display:flex;justify-content:space-between;align-items:center}
  #status{display:flex;gap:12px;align-items:center}
  #msg{background:#0008;padding:8px;border-radius:6px;min-width:220px}
  #canvas-wrap{margin:10px auto; width:640px; background:#000;}
  canvas{display:block; background:#000;}
  .class-btn{padding:6px 10px;background:#1b1f34;border-radius:6px;border:1px solid #333;color:#fff;cursor:pointer}
  .class-btn.active{outline:2px solid #9cf}
  .xp-bar{width:220px;height:12px;background:#222;border:1px solid #444;border-radius:6px;overflow:hidden}
  .xp-fill{height:100%;background:linear-gradient(90deg,#7ad,#3ad);width:0%}
</style>
</head>
<body>
  <h1>Pixel RPG — Adventure</h1>
  <div id="ui">
    <div>
      <button class="class-btn" data-class="hero" id="btn-hero">勇者</button>
      <button class="class-btn" data-class="wizard" id="btn-wizard">魔法使い</button>
      <button class="class-btn" data-class="assassin" id="btn-assassin">暗殺者</button>
      <!-- エリア移動ボタン -->
      <button id="btn-sea" style="margin-left:12px;padding:6px 10px;border-radius:6px;background:#0b4b6f;color:#fff;border:1px solid #234">海へ</button>
      <button id="btn-overworld" style="margin-left:6px;display:none;padding:6px 10px;border-radius:6px;background:#2b5f2b;color:#fff;border:1px solid #234">陸へ戻る</button>
    </div>
    <div id="status">
      <div class="bar" id="player-stats">
        <div>Lv <span id="pl-lv">1</span> <strong id="pl-name">勇者</strong></div>
        <div>HP <span id="pl-hp">10</span>/<span id="pl-maxhp">10</span></div>
      </div>
      <div class="xp-bar"><div id="xp-fill" class="xp-fill"></div></div>
      <div id="enemy-info" class="bar">敵: なし</div>
    </div>
    <div id="msg">ロード中…</div>
  </div>

  <div id="canvas-wrap">
    <canvas id="game" width="640" height="416"></canvas> <!-- 13行 * 32px = 416 -->
    <div id="loading" style="color:#9cf;margin:6px">画像読み込み中...</div>
  </div>

<script>
/*--- 基本設定 ---*/
const TILE = 32;
const VIEW_W = 20, VIEW_H = 13; // 下側に1行増やす
const MAP_W = 80, MAP_H = 50;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const msgEl = document.getElementById('msg');
const loadingEl = document.getElementById('loading');
const xpFillEl = document.getElementById('xp-fill');

const grassUrls = [
  "{% static 'grass_0.png' %}",
  "{% static 'grass_1.png' %}",
  "{% static 'grass_2.png' %}",
  "{% static 'grass_3.png' %}",
  "{% static 'grass_4.png' %}",
  "{% static 'grass_5.png' %}"
];
const decorUrls = {
  village: "{% static 'village.png' %}",
  rock: "{% static 'rock.png' %}",
  water: "{% static 'water.png' %}"
};
function frameUrl(cls, dir, idx){
  return "{% static 'PLACEHOLDER' %}".replace('PLACEHOLDER', cls + "_" + dir + "_" + idx + ".png");
}
const classes = ['hero','wizard','assassin'];
const dirs = ['down','left','right','up'];

/*--- 画像プリロード（省略表示は以前と同様） ---*/
let grassImgs = [];
let tileImgs = {};
let playerFrames = {};
let toLoad = 0, loaded = 0;
function addImage(url, targetArr){
  toLoad++;
  const im = new Image(); im.src = url;
  im.onload = ()=>{ loaded++; checkAllLoaded(); };
  im.onerror = ()=>{ console.warn("failed load", url); loaded++; checkAllLoaded(); };
  if(Array.isArray(targetArr)) targetArr.push(im);
  return im;
}
grassUrls.forEach(u => addImage(u, grassImgs));
tileImgs.village = addImage(decorUrls.village, []);
tileImgs.rock = addImage(decorUrls.rock, []);
tileImgs.water = addImage(decorUrls.water, []);
classes.forEach(c=>{
  playerFrames[c] = {};
  dirs.forEach(d=>{
    playerFrames[c][d] = [];
    for(let f=0; f<3; f++){
      addImage(frameUrl(c,d,f), playerFrames[c][d]);
    }
  });
});
checkAllLoaded();
function checkAllLoaded(){
  loadingEl.textContent = `画像読み込み中... (${loaded}/${toLoad})`;
  if(loaded < toLoad) return;
  loadingEl.style.display = 'none';
  msgEl.textContent = "ロード完了。矢印キーで移動。Spaceで攻撃。";
  initAfterLoad();
}

/*--- マップ関連 ---*/
const TILE_TYPE = {VILLAGE:6, ROCK:7, WATER:8, HEAL:9};
let MAP = new Array(MAP_H);
let currentArea = 'overworld'; // 'overworld' | 'sea'

// 港一覧（ここに座標を追加してください）
const PORTS = [{x:10, y:8}];

// generateMap を呼んだあとに港タイルを配置するヘルパー
function placePortsOnMap(){
  for(const p of PORTS){
    if(p.x >= 0 && p.x < MAP_W && p.y >= 0 && p.y < MAP_H){
      MAP[p.y][p.x] = TILE_TYPE.VILLAGE; // 見た目は村タイルにする（任意で変更可）
    }
  }
}

function generateMap(area='overworld'){
  currentArea = area;
  MAP = new Array(MAP_H);
  for(let y=0;y<MAP_H;y++){
    MAP[y] = new Array(MAP_W);
    for(let x=0;x<MAP_W;x++){
      if(area === 'sea'){
        if(Math.random() < 0.02) MAP[y][x] = TILE_TYPE.VILLAGE;
        else if(Math.random() < 0.12) MAP[y][x] = TILE_TYPE.WATER;
        else if(Math.random() < 0.03) MAP[y][x] = TILE_TYPE.ROCK;
        else if(Math.random() < 0.006) MAP[y][x] = TILE_TYPE.HEAL;
        else MAP[y][x] = Math.random() < 0.15 ? Math.floor(Math.abs(Math.sin(x*0.3+y*0.2)) * grassUrls.length) : TILE_TYPE.WATER;
      } else {
        if(Math.random() < 0.005) MAP[y][x] = TILE_TYPE.VILLAGE;
        else if(Math.random() < 0.03) MAP[y][x] = TILE_TYPE.ROCK;
        else if(Math.random() < 0.02) MAP[y][x] = TILE_TYPE.WATER;
        else if(Math.random() < 0.006) MAP[y][x] = TILE_TYPE.HEAL;
        else MAP[y][x] = Math.floor(Math.abs(Math.sin(x*0.3+y*0.2)) * grassUrls.length);
      }
    }
  }
  placePortsOnMap();
}

// 初期は陸地を生成
generateMap('overworld');
// spawnInitialEnemies は initAfterLoad から呼ばれるのでここでは敵は作られない

/*--- クラス別ステータスの永続化（localStorage） ---*/
function defaultStatsFor(cls){
  if(cls==='hero') return {level:1,xp:0,xpToNext:100,maxHp:36,hp:36,atk:7};
  if(cls==='wizard') return {level:1,xp:0,xpToNext:100,maxHp:28,hp:28,atk:9};
  return {level:1,xp:0,xpToNext:100,maxHp:30,hp:30,atk:8}; // assassin
}
function loadStats(cls){
  const key = 'rpg_stats_'+cls;
  const raw = localStorage.getItem(key);
  if(raw) return JSON.parse(raw);
  const def = defaultStatsFor(cls);
  localStorage.setItem(key, JSON.stringify(def));
  return def;
}
function saveStats(cls, stats){
  const key = 'rpg_stats_'+cls;
  localStorage.setItem(key, JSON.stringify(stats));
}

/*--- プレイヤー状態（現在画面用） ---*/
let player = {
  x: Math.floor(MAP_W/2),
  y: Math.floor(MAP_H/2),
  cls: 'hero',
  dir: 'down',
  frame:0, tick:0,
  atkCooldown:0,
  healTickCounter:0,
  // stats are loaded per-class below
  level:1,xp:0,xpToNext:100,maxHp:30,hp:30,atk:6
};

function applyClassStats(cls){
  const s = loadStats(cls);
  player.level = s.level; player.xp = s.xp; player.xpToNext = s.xpToNext;
  player.maxHp = s.maxHp; player.hp = s.hp; player.atk = s.atk;
  updateHud();
}
function persistClassStats(){
  const s = {level:player.level,xp:player.xp,xpToNext:player.xpToNext,maxHp:player.maxHp,hp:player.hp,atk:player.atk};
  saveStats(player.cls, s);
}

/*--- XP / レベル処理（クラス別） ---*/
function xpGain(amount){
  player.xp += amount;
  while(player.xp >= player.xpToNext){
    player.xp -= player.xpToNext;
    player.level += 1;
    player.maxHp += 8; player.atk += 2; player.hp = player.maxHp;
    player.xpToNext = Math.floor(player.xpToNext * 1.4);
    showFloatingText("Level Up!", (canvas.width/2)-20, 20, '#9cf');
  }
  persistClassStats();
  updateHud();
}
function updateHud(){
  document.getElementById('pl-lv').textContent = player.level;
  document.getElementById('pl-name').textContent = player.cls === 'hero' ? '勇者' : (player.cls === 'wizard' ? '魔法使い' : '暗殺者');
  document.getElementById('pl-hp').textContent = player.hp;
  document.getElementById('pl-maxhp').textContent = player.maxHp;
  const pct = Math.min(100, Math.floor(player.xp / player.xpToNext * 100));
  xpFillEl.style.width = pct + "%";
}

/*--- 敵管理（省略: 以前の spawnEnemy 等を使用） ---*/
let enemies = []; let nextEnemyId = 1;
function canPlace(x,y, sizeX=1, sizeY=1){
  if(x<0||y<0||x+sizeX-1>=MAP_W||y+sizeY-1>=MAP_H) return false;
  for(let yy=y; yy<y+sizeY; yy++){
    for(let xx=x; xx<x+sizeX; xx++){
      const t = MAP[yy][xx];
      if(t===TILE_TYPE.ROCK||t===TILE_TYPE.WATER) return false;
      if(xx===player.x && yy===player.y) return false;
      for(const e of enemies){
        if(e.kind === 'boss' && Array.isArray(e.segments)){
          for(const s of e.segments){
            if(s.x === xx && s.y === yy) return false;
          }
        } else {
          const esx = e.sizeX || (e.size || 1);
          const esy = e.sizeY || (e.size || 1);
          if(xx >= e.x && xx < e.x + esx && yy >= e.y && yy < e.y + esy) return false;
        }
      }
    }
  }
  return true;
}

function enemyAt(x,y){
  return enemies.find(e => {
    if(e.kind === 'boss' && Array.isArray(e.segments)){
      return e.segments.some(s=>s.x===x && s.y===y);
    }
    const esx = e.sizeX || (e.size || 1);
    const esy = e.sizeY || (e.size || 1);
    return x >= e.x && x < e.x + esx && y >= e.y && y < e.y + esy;
  });
}

function spawnEnemy(kind='goblin', near=false){
  const base = {
    goblin:{maxHp:12,atk:3,xp:20,color:'#c55',moveFreq:3,sizeX:1,sizeY:1},
    slime:{maxHp:8,atk:2,xp:12,color:'#5c5',moveFreq:3,sizeX:1,sizeY:1},
    wolf:{maxHp:16,atk:4,xp:30,color:'#a63',moveFreq:3,sizeX:1,sizeY:1},
    archer:{maxHp:10,atk:3,xp:25,color:'#a96',moveFreq:3,sizeX:1,sizeY:1},
    metal:{maxHp:2,atk:1,xp:300,color:'#dfe6ff',moveFreq:1,sizeX:1,sizeY:1},
    miniboss:{maxHp:120,atk:18,xp:250,color:'#8b0000',moveFreq:3,sizeX:2,sizeY:2},
    // 大ボス：snake (長さ6)。moveFreq遅め(4)、高HP、高ATK、特殊攻撃を持つ
    boss:{maxHp:800,atk:28,xp:2000,color:'#442200',moveFreq:4,sizeX:6,sizeY:1}
  };
  const stats = base[kind] || base.goblin;
  let x,y,tries=0;
  do {
    if(near){ const dx = Math.floor((Math.random()*10)-5), dy = Math.floor((Math.random()*10)-5); x = Math.max(0,Math.min(MAP_W-1,player.x + dx)); y = Math.max(0,Math.min(MAP_H-1,player.y + dy)); }
    else { x = Math.floor(Math.random()*MAP_W); y = Math.floor(Math.random()*MAP_H); }
    tries++; if(tries>800) break;
    // boss は向き (h/v) を考慮して試行
    if(kind === 'boss'){
      // choose orientation temporarily; we'll validate later
      const orient = Math.random() < 0.5 ? 'h' : 'v';
      if(orient === 'h'){
        if(!canPlace(x,y, stats.sizeX, 1)) continue;
      } else {
        if(!canPlace(x,y, 1, stats.sizeX)) continue;
      }
      // ok
      const e = { id: nextEnemyId++, kind, x, y, maxHp: stats.maxHp, hp: stats.maxHp, atk: stats.atk, xpReward: stats.xp, color: stats.color, tick:0, moveFreq: stats.moveFreq, sizeX: stats.sizeX, sizeY: stats.sizeY, orient };
      // build segments (head at index 0)
      e.segments = [];
      if(orient === 'h'){
        for(let i=0;i<stats.sizeX;i++) e.segments.push({x: x + i, y: y});
      } else {
        for(let i=0;i<stats.sizeX;i++) e.segments.push({x: x, y: y + i});
      }
      enemies.push(e);
      return e;
    }
  } while(!canPlace(x,y, stats.sizeX, stats.sizeY));
  // 通常の矩形敵
  const e = { id: nextEnemyId++, kind, x, y, maxHp: stats.maxHp, hp: stats.maxHp, atk: stats.atk, xpReward: stats.xp, color: stats.color, tick:0, moveFreq: stats.moveFreq || 3, sizeX: stats.sizeX || 1, sizeY: stats.sizeY || 1 };
  enemies.push(e); return e;
}

function spawnInitialEnemies(n=6){
  for(let i=0;i<n;i++){
    // miniboss 出現率を約10% に変更
    if(Math.random() < 0.20){ spawnEnemy('miniboss'); }
    else if(Math.random() < 0.05){ spawnEnemy('metal'); } // metal は希少
    else spawnEnemy(Math.random()<0.5 ? 'goblin' : (Math.random()<0.5?'slime':'wolf'));
  }
  // 低確率で大ボスを混ぜたい場合はここで確率指定 (例: 0.005)
  if(Math.random() < 0.8){ spawnEnemy('boss'); }
}

/*---  描画・補助 ---*/
let floatingTexts = [], attackIndicators = [];
function showFloatingText(text, x, y, color='#fff'){ floatingTexts.push({text,x,y,color,life:40}); }
function addIndicatorLine(tx,ty,color,life=18){ attackIndicators.push({x:tx,y:ty,color,life}); }
function camOrigin(){ let ox = player.x - Math.floor(VIEW_W/2), oy = player.y - Math.floor(VIEW_H/2); ox = Math.max(0, Math.min(MAP_W-VIEW_W, ox)); oy = Math.max(0, Math.min(MAP_H-VIEW_H, oy)); return {ox, oy}; }

function draw(){
  updateHud();
  const {ox, oy} = camOrigin();
  ctx.fillStyle = '#071012'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let vy=0; vy<VIEW_H; vy++){
    for(let vx=0; vx<VIEW_W; vx++){
      const mx = ox+vx, my = oy+vy; const t = MAP[my][mx];
      if(t >= 0 && t < grassImgs.length){ const img = grassImgs[t]; if(img && img.complete) ctx.drawImage(img, vx*TILE, vy*TILE, TILE, TILE); else ctx.fillStyle = '#3c7', ctx.fillRect(vx*TILE, vy*TILE, TILE, TILE); }
      else if(t === TILE_TYPE.VILLAGE){ const img = tileImgs.village; if(img && img.complete) ctx.drawImage(img, vx*TILE, vy*TILE, TILE, TILE); else ctx.fillStyle='#aa8', ctx.fillRect(vx*TILE, vy*TILE, TILE, TILE); }
      else if(t === TILE_TYPE.ROCK){ const img = tileImgs.rock; if(img && img.complete) ctx.drawImage(img, vx*TILE, vy*TILE, TILE, TILE); else ctx.fillStyle='#777', ctx.fillRect(vx*TILE, vy*TILE, TILE, TILE); }
      else if(t === TILE_TYPE.WATER){ const img = tileImgs.water; if(img && img.complete) ctx.drawImage(img, vx*TILE, vy*TILE, TILE, TILE); else ctx.fillStyle='#18a', ctx.fillRect(vx*TILE, vy*TILE, TILE, TILE); }
      else if(t === TILE_TYPE.HEAL){ ctx.fillStyle = '#103'; ctx.fillRect(vx*TILE, vy*TILE, TILE, TILE); ctx.fillStyle = '#6f6'; ctx.beginPath(); ctx.arc(vx*TILE+TILE/2, vy*TILE+TILE/2, TILE/4, 0, Math.PI*2); ctx.fill(); }
    }
  }
  // enemies 描画をサイズ対応に変更
  for(const e of enemies){
    const ex = (e.x - ox)*TILE, ey = (e.y - oy)*TILE;
    if(e.kind === 'boss' && Array.isArray(e.segments)){
      // 蛇状大ボス：各セグメントを順に描画（頭は明るめ）
      for(let si=0; si<e.segments.length; si++){
        const s = e.segments[si];
        const sx = (s.x - ox)*TILE, sy = (s.y - oy)*TILE;
        ctx.fillStyle = si === 0 ? '#aa6b2b' : '#664421';
        ctx.fillRect(sx + 2, sy + 2, TILE - 4, TILE - 4);
      }
      // HPバー（頭上に大きめ）
      const head = e.segments[0];
      const hx = (head.x - ox)*TILE, hy = (head.y - oy)*TILE;
      const hpPct = Math.max(0, e.hp / e.maxHp);
      // 幅を1タイル分に変更（中央揃え）
      const hpW = TILE;
      const hpX = hx + Math.floor((TILE - hpW) / 2);
      ctx.fillStyle = '#000';
      ctx.fillRect(hpX, hy - 6, hpW, 5);
      ctx.fillStyle = '#f55';
      ctx.fillRect(hpX, hy - 6, Math.floor(hpW * hpPct), 5);
      continue;
    }
    // 既存の矩形敵描画（sizeX/sizeY 使用）
    const esx = e.sizeX || 1, esy = e.sizeY || 1;
    const w = TILE * esx, h = TILE * esy;
    ctx.fillStyle = e.color || '#f55';
    ctx.fillRect(ex + 4, ey + 4, w - 8, h - 8);
    if(!e.npc){
      const hpPct = Math.max(0, e.hp / e.maxHp);
      ctx.fillStyle='#000'; ctx.fillRect(ex+4, ey+2, w-8, 4);
      ctx.fillStyle='#f55'; ctx.fillRect(ex+4, ey+2, Math.floor((w-8)*hpPct), 4);
    }
  }
  // indicators
  for(let i=attackIndicators.length-1;i>=0;i--){ const ind=attackIndicators[i]; const px=(ind.x-ox)*TILE, py=(ind.y-oy)*TILE; ctx.globalAlpha = Math.max(0.15, ind.life/20); ctx.fillStyle = ind.color; ctx.fillRect(px, py, TILE, TILE); ctx.globalAlpha = 1; ind.life--; if(ind.life<=0) attackIndicators.splice(i,1); }
  // player
  const {ox:cx, oy:cy} = camOrigin();
  const px = (player.x - cx) * TILE;
  const py = (player.y - cy) * TILE - (player.frame % 2 === 0 ? 2 : 0);
  const frames = playerFrames[player.cls] && playerFrames[player.cls][player.dir] ? playerFrames[player.cls][player.dir] : [];
  const im = frames.length ? frames[player.frame % frames.length] : null;
  if(im && im.complete) ctx.drawImage(im, px, py, TILE, TILE); else { ctx.fillStyle='#ff0'; ctx.fillRect(px+8, py+8, 16, 16); }
  // floating
  for(let i=floatingTexts.length-1;i>=0;i--){ const f=floatingTexts[i]; ctx.globalAlpha=f.life/40; ctx.fillStyle=f.color; ctx.font="14px Meiryo"; ctx.fillText(f.text, f.x, f.y); ctx.globalAlpha=1; f.y-=0.6; f.life--; if(f.life<=0) floatingTexts.splice(i,1); }
}

/*--- 当たり判定/ユーティリティ ---*/
function is_block(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; const t = MAP[y][x]; if(t === TILE_TYPE.ROCK) return true; if(t === TILE_TYPE.WATER) return (currentArea !== 'sea'); // seaでは川/海を歩ける return false; }
function dirVector(dir){ if(dir==='up') return {dx:0,dy:-1}; if(dir==='down') return {dx:0,dy:1}; if(dir==='left') return {dx:-1,dy:0}; return {dx:1,dy:0}; }}

/*--- 攻撃処理 ---*/
// 通常攻撃: 前方1マス
function playerAttack(){
  if(player.atkCooldown>0) return;
  player.atkCooldown = 8;
  const v = dirVector(player.dir);
  const tx = player.x + v.dx, ty = player.y + v.dy;
  addIndicatorLine(tx, ty, 'rgba(255,200,100,0.9)', 12);
  const targets = enemies.filter(e => e.x === tx && e.y === ty);
  if(targets.length === 0){ showFloatingText("空振り", (canvas.width/2)-10, 40, '#ccc'); return; }
  for(const target of targets){
    const dmg = Math.max(1, player.atk + (Math.floor(Math.random()*3)-1));
    target.hp -= dmg;
    showFloatingText("-"+dmg, (tx - camOrigin().ox)*TILE + 12, (ty - camOrigin().oy)*TILE + 16, '#f88');
    if(target.hp <= 0){ enemies = enemies.filter(e => e.id !== target.id); xpGain(target.xpReward); showFloatingText("倒した！ +" + target.xpReward + "XP", (tx - camOrigin().ox)*TILE + 8, (ty - camOrigin().oy)*TILE + 8, '#9f9'); if(Math.random()<0.4) spawnEnemy(); }
  }
}

// 勇者: 前方1〜3マスを対象に範囲ダメージ（周辺はそのマスにいる全ての敵に判定）
function heroSlash3(){
  if(player.atkCooldown>0) return;
  if(player.cls !== 'hero'){ showFloatingText("勇者にだけ使用可", canvas.width/2-30, 40, '#ccc'); return; }
  player.atkCooldown = 14;
  const v = dirVector(player.dir);
  for(let i=1;i<=3;i++){
    const tx = player.x + v.dx * i, ty = player.y + v.dy * i;
    addIndicatorLine(tx, ty, 'rgba(255,120,50,0.95)', 18);
    const targets = enemies.filter(e => e.x === tx && e.y === ty);
    for(const target of targets){
      const dmg = Math.max(1, player.atk + (Math.floor(Math.random()*3)-1));
      target.hp -= dmg;
      showFloatingText("-"+dmg, (tx - camOrigin().ox)*TILE + 12, (ty - camOrigin().oy)*TILE + 16, '#f88');
      if(target.hp <= 0){ enemies = enemies.filter(e => e.id !== target.id); xpGain(target.xpReward); showFloatingText("倒した！ +" + target.xpReward + "XP", (tx - camOrigin().ox)*TILE + 8, (ty - camOrigin().oy)*TILE + 8, '#9f9'); }
    }
  }
}

// 魔法使い: 仕様変更 — マップ上の自分以外のマスからランダムで"3つ"選んで攻撃（範囲ダメージ）
function wizardRanged4(){
  if(player.atkCooldown>0) return;
  if(player.cls !== 'wizard'){ showFloatingText("魔法使いだけ使用可", canvas.width/2-30, 40, '#ccc'); return; }
  // 5秒クールダウン（140ms tick -> 36）
  player.atkCooldown = 36;
  // ビューポート内のタイル列挙（プレイヤー自身は除外）
  const {ox, oy} = camOrigin();
  const visible = [];
  for(let yy = oy; yy < oy + VIEW_H; yy++){
    for(let xx = ox; xx < ox + VIEW_W; xx++){
      if(xx === player.x && yy === player.y) continue;
      visible.push({x: xx, y: yy});
    }
  }
  if(visible.length === 0) return;
  // 最大15タイルをランダム選択
  const picks = [];
  const maxPick = Math.min(15, visible.length);
  while(picks.length < maxPick){
    const i = Math.floor(Math.random() * visible.length);
    picks.push(visible.splice(i,1)[0]);
  }
  // 各選択タイルにエフェクト＋周辺ダメージ（マンハッタン<=1）
  for(const p of picks){
    addIndicatorLine(p.x, p.y, 'rgba(80,200,255,0.95)', 22);
    const aoeTargets = enemies.filter(e => Math.abs(e.x - p.x) + Math.abs(e.y - p.y) <= 1);
    for(const target of aoeTargets){
      const dmg = Math.max(1, player.atk + 3 + (Math.floor(Math.random()*4)-2));
      target.hp -= dmg;
      showFloatingText("-"+dmg, (target.x - camOrigin().ox)*TILE + 12, (target.y - camOrigin().oy)*TILE + 16, '#9cf');
      if(target.hp <= 0){
        enemies = enemies.filter(e => e.id !== target.id);
        xpGain(target.xpReward);
        showFloatingText("倒した！ +" + target.xpReward + "XP", (target.x - camOrigin().ox)*TILE + 8, (target.y - camOrigin().oy)*TILE + 8, '#9f9');
        if(Math.random()<0.4) spawnEnemy();
      }
    }
  }
}

function assassinExecute(){
  if(player.atkCooldown>0) return;
  if(player.cls !== 'assassin'){ showFloatingText("暗殺者だけ使用可", canvas.width/2-30, 40, '#ccc'); return; }
  player.atkCooldown = 18;
  const v = dirVector(player.dir);
  // 前方5マス目
  const tx = player.x + v.dx * 5, ty = player.y + v.dy * 5;
  // 2x2の四角（tx,ty）、(tx+1,ty)、(tx,ty+1)、(tx+1,ty+1）
  const area = [
    {x:tx, y:ty},
    {x:tx+1, y:ty},
    {x:tx, y:ty+1},
    {x:tx+1, y:ty+1}
  ];
  for(const cell of area){
    addIndicatorLine(cell.x, cell.y, 'rgba(40,40,40,0.95)', 22);
  }
  const targets = enemies.filter(e => area.some(a => a.x === e.x && a.y === e.y));
  if(targets.length === 0){ showFloatingText("対象がいない", canvas.width/2-10, 40, '#ccc'); return; }
  for(const t of targets){
    enemies = enemies.filter(e => e.id !== t.id);
    showFloatingText("暗殺！ +" + t.xpReward + "XP", (t.x - camOrigin().ox)*TILE + 8, (t.y - camOrigin().oy)*TILE + 8, '#f9d');
    xpGain(t.xpReward);
    if(Math.random()<0.4) spawnEnemy();
  }
}

/*--- 敵行動 ---*/
function enemyTick(){
  for(const e of enemies){
    e.tick = (e.tick || 0) + 1;
    if(e.tick % (e.moveFreq || 3) !== 0) continue;

    // boss の特別挙動
    if(e.kind === 'boss'){
      // head は segments[0]
      const head = e.segments[0];
      // 距離
      const dist = Math.abs(head.x - player.x) + Math.abs(head.y - player.y);

      // 近距離なら範囲攻撃（3x3 中央=head）
      if(dist <= 3 && Math.random() < 0.5){
        // indicator とダメージ
        for(let ay = head.y-1; ay <= head.y+1; ay++){
          for(let ax = head.x-1; ax <= head.x+1; ax++){
            addIndicatorLine(ax, ay, 'rgba(200,80,40,0.95)', 26);
            // プレイヤーが被弾
            if(player.x === ax && player.y === ay){
              const dmg = Math.max(1, e.atk + (Math.floor(Math.random()*4)-2));
              player.hp = Math.max(0, player.hp - dmg);
              showFloatingText("-"+dmg, canvas.width/2, 40, '#f55');
              if(player.hp <= 0){ msgEl.textContent = "やられた... リスポーンします（レベル維持）"; player.hp = player.maxHp; player.x = Math.floor(MAP_W/2); player.y = Math.floor(MAP_H/2); persistClassStats(); }
            }
          }
        }
        continue; // 攻撃したらそのターンは移動しない
      }

      // 遠距離直線攻撃（頭からプレイヤー方向への射線、射程6）>
      if(dist <= 10 && Math.random() < 0.3){
        const dx = Math.sign(player.x - head.x), dy = Math.sign(player.y - head.y);
        let bx = head.x, by = head.y;
        for(let i=1;i<=6;i++){
          bx += dx; by += dy;
          addIndicatorLine(bx, by, 'rgba(180,120,255,0.95)', 18);
          // 命中判定（プレイヤー）
          if(player.x === bx && player.y === by){
            const dmg = Math.max(1, Math.floor(e.atk * 0.9));
            player.hp = Math.max(0, player.hp - dmg);
            showFloatingText("-"+dmg, canvas.width/2, 40, '#f5a');
            if(player.hp <= 0){ msgEl.textContent = "やられた... リスポーンします（レベル維持）"; player.hp = player.maxHp; player.x = Math.floor(MAP_W/2); player.y = Math.floor(MAP_H/2); persistClassStats(); }
            break;
          }
        }
        continue;
      }

      // 移動: head に向けて近づく or ランダムに進む。蛇状は segments をシフト
      // 優先: プレイヤー方向へ1マス (head)
      let hx = head.x, hy = head.y;
      if(Math.random() < 0.8){
        if(head.x < player.x) hx++;
        else if(head.x > player.x) hx--;
        if(head.y < player.y) hy++;
        else if(head.y > player.y) hy--;
        // 少しランダム化で片方向のみ移動する場合がある
        if(Math.random() < 0.6){ if(Math.random()<0.5) hy = head.y; else hx = head.x; }
      } else {
        const dir = Math.floor(Math.random()*4);
        if(dir===0) hx = head.x+1;
        if(dir===1) hx = head.x-1;
        if(dir===2) hy = head.y+1;
        if(dir===3) hy = head.y-1;
      }
      // 新head位置が移動可能か（全セグメント置換しても衝突しないか）を検査
      const newSegs = [{x:hx,y:hy}];
      for(let i=1;i<e.segments.length;i++){
        newSegs.push({x: e.segments[i-1].x, y: e.segments[i-1].y});
      }
      // collision チェック
      let ok = true;
      for(const s of newSegs){
        if(s.x<0||s.y<0||s.x>=MAP_W||s.y>=MAP_H){ ok = false; break; }
        if(MAP[s.y][s.x] === TILE_TYPE.ROCK || MAP[s.y][s.x] === TILE_TYPE.WATER){ ok = false; break; }
        // check other enemies footprint
        for(const oe of enemies){
          if(oe.id === e.id) continue;
          if(oe.kind === 'boss' && Array.isArray(oe.segments)){
            for(const os of oe.segments) if(os.x===s.x && os.y===s.y){ ok = false; break; }
            if(!ok) break;
          } else {
            const oxs = oe.sizeX || (oe.size || 1);
            const oys = oe.sizeY || (oe.size || 1);
            if(s.x >= oe.x && s.x < oe.x + oxs && s.y >= oe.y && s.y < oe.y + oys){ ok = false; break; }
          }
        }
        if(!ok) break;
        // don't move onto player
        if(s.x === player.x && s.y === player.y){ ok = false; break; }
      }
      if(ok){
        e.segments = newSegs;
        // 蛇状移動：全体を1マスシフト
        const tail = e.segments.pop();
        e.segments.unshift(tail);
      }
    }

    // 既存の敵行動（従来の挙動を保持）
    if(Math.abs(e.x - player.x) + Math.abs(e.y - player.y) === 1){
      if(Math.random() < 0.5){
        const dmg = Math.max(1, e.atk + (Math.floor(Math.random()*2)-1));
        player.hp = Math.max(0, player.hp - dmg);
        showFloatingText("-"+dmg, canvas.width/2, 30, '#f55');
        if(player.hp <= 0){
          msgEl.textContent = "やられた... リスポーンします（レベル維持）";
          player.hp = player.maxHp;
          player.x = Math.floor(MAP_W/2); player.y = Math.floor(MAP_H/2);
          persistClassStats();
        }
      }
      continue;
    }
    const dist = Math.abs(e.x - player.x) + Math.abs(e.y - player.y);
    let nx = e.x, ny = e.y;
    if(dist <= 6 && Math.random() < 0.7){
      if(e.x < player.x) nx++;
      else if(e.x > player.x) nx--;
      if(e.y < player.y) ny++;
      else if(e.y > player.y) ny--;
      if(Math.random()<0.5){ ny = e.y; } else { nx = e.x; }
    } else {
      const dir = Math.floor(Math.random()*4);
      if(dir===0) nx = e.x+1;
      if(dir===1) nx = e.x-1;
      if(dir===2) ny = e.y+1;
      if(dir===3) ny = e.y-1;
    }
    // 敵移動判定の際、新座標が多タイル用でも canPlace を用いてチェックするよう修正
    // （例の一部）―― enemyTick 内、nx,ny を決めた後の配置判定を以下のように
    if(!is_block(nx,ny) && !enemyAt(nx,ny) && canPlace(nx,ny, e.size || 1) && !(nx===player.x && ny===player.y)){ e.x = nx; e.y = ny; }
  }
}

/*--- 移動・バンプ攻撃 ---*/
function attemptMove(nx, ny){
  if(is_block(nx, ny)) { msgEl.textContent = "進めない！"; return false; }
  const e = enemyAt(nx, ny);
  if(e){
    const dmg = Math.max(1, Math.floor(player.atk/2));
    e.hp -= dmg;
    showFloatingText("-"+dmg, (nx - camOrigin().ox)*TILE + 12, (ny - camOrigin().oy)*TILE + 16, '#f88');
    if(e.hp <= 0){ enemies = enemies.filter(x=>x.id !== e.id); xpGain(e.xpReward); showFloatingText("倒した！ +" + e.xpReward + "XP", (nx - camOrigin().ox)*TILE + 8, (ny - camOrigin().oy)*TILE + 8, '#9f9'); }
    return false;
  }
  player.x = nx; player.y = ny; player.tick = 6;
  if(MAP[ny][nx] === TILE_TYPE.VILLAGE) { msgEl.textContent = "村に到着した！ (Zで入る)"; }
  else { msgEl.textContent = "移動した。"; }
  return true;
}

// エリア切替処理
function switchArea(area){
  // プレイヤー位置を安全な場所に移動（中央付近）
  player.x = Math.floor(MAP_W/2);
  player.y = Math.floor(MAP_H/2);
  // MAP 再生成、敵クリア、再スポーン
  generateMap(area);
  enemies = [];
  spawnInitialEnemies(8);
  // UI ボタン表示切替
  document.getElementById('btn-sea').style.display = (area === 'sea') ? 'none' : 'inline-block';
  document.getElementById('btn-overworld').style.display = (area === 'sea') ? 'inline-block' : 'none';
  msgEl.textContent = (area === 'sea') ? '海マップに移動しました。' : '陸地に戻りました。';
  draw();
}
document.getElementById('btn-sea').addEventListener('click', ()=> switchArea('sea'));
document.getElementById('btn-overworld').addEventListener('click', ()=> switchArea('overworld'));

/*--- 入力 ---*/
document.addEventListener('keydown', (e)=>{
  // 港でエリア切替
  if(e.key === 'o' || e.key === 'O' || e.key === 'Enter'){
    for(const p of PORTS){
      if(player.x === p.x && player.y === p.y){
        if(currentArea === 'overworld') switchArea('sea');
        else switchArea('overworld');
        e.preventDefault();
        return;
      }
    }
  }

  if(e.key === ' '){ e.preventDefault(); playerAttack(); return; }
  if(e.key === 'x' || e.key === 'X'){ heroSlash3(); return; }
  if(e.key === 'c' || e.key === 'C'){ wizardRanged4(); return; }
  if(e.key === 'v' || e.key === 'V'){ assassinExecute(); return; }
  if(e.key === 'z' || e.key === 'Z'){
    if(MAP[player.y][player.x] === TILE_TYPE.VILLAGE){
      // 家に入る（別画面遷移） — クラスはクエリで渡す。ステータスは localStorage で管理しているため問題なし
      const cls = encodeURIComponent(player.cls);
      window.location.href = `/house/?cls=${cls}`;
    }
    return;
  }
  let moved=false;
  if(e.key==='ArrowUp'){ player.dir='up'; moved = attemptMove(player.x, player.y-1); }
  if(e.key==='ArrowDown'){ player.dir='down'; moved = attemptMove(player.x, player.y+1); }
  if(e.key==='ArrowLeft'){ player.dir='left'; moved = attemptMove(player.x-1, player.y); }
  if(e.key==='ArrowRight'){ player.dir='right'; moved = attemptMove(player.x+1, player.y); }
  if(moved) draw();
});

/*--- ゲームループ ---*/
setInterval(()=>{
  if(player.atkCooldown > 0) player.atkCooldown--;
  if(player.tick > 0){ player.tick--; player.frame++; }
  // 回復タイル
  const tUnder = MAP[player.y][player.x];
  if(tUnder === TILE_TYPE.HEAL){
    player.healTickCounter = (player.healTickCounter || 0) + 1;
    if(player.healTickCounter % 5 === 0){
      player.hp = Math.min(player.maxHp, player.hp + 3);
      showFloatingText("+3", canvas.width/2, 40, '#6f6');
    }
  } else { player.healTickCounter = 0; }
  enemyTick();
  draw();
}, 140);

/*--- UIボタン（クラス切替） ---*/
document.querySelectorAll('.class-btn').forEach(b=>{
  b.addEventListener('click', ()=>{
    document.querySelectorAll('.class-btn').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    player.cls = b.dataset.class;
    applyClassStats(player.cls);
    msgEl.textContent = b.textContent + " を選択しました。";
    draw();
  });
});
document.getElementById('btn-hero').classList.add('active');
applyClassStats('hero');

/*--- 初期化 ---*/
function initAfterLoad(){
  // generateMap('overworld'); // 既にロード時に生成済み
  spawnInitialEnemies(10);
  updateHud();
  draw();
  msgEl.textContent = "矢印キーで移動。Space=攻撃 X=勇者3連斬 C=魔法(ランダム) V=暗殺 Z=村へ入る";
}

</script>
</body>
</html>